var documenterSearchIndex = {"docs":
[{"location":"ModelingConcepts/#Modeling-Concepts","page":"Modeling Concepts","title":"Modeling Concepts","text":"","category":"section"},{"location":"ModelingConcepts/#Terminal","page":"Modeling Concepts","title":"Terminal","text":"","category":"section"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"The Terminal─Connector is an important building block for every model. It represents a connection point with constant voltage in dq─cordinates u_r and u_i and enforces the kirchoff constraints sum(i_r)=0 and sum(i_i)=0.","category":"page"},{"location":"ModelingConcepts/#Modeling-of-Buses","page":"Modeling Concepts","title":"Modeling of Buses","text":"","category":"section"},{"location":"ModelingConcepts/#Model-class-Injector","page":"Modeling Concepts","title":"Model class Injector","text":"","category":"section"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"An injector is a class of components with a single Terminal() (called :terminal). Examples for injectors might be Generators, Shunts, Loads.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"      ┌───────────┐\n(t)   │           │\n o←───┤  Injector │\n      │           │\n      └───────────┘","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"The current for injectors is always in injector convention, i.e. positive currents flow out of the injector towards the terminal.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"note: Model classes\nModel \"classes\" are nothing formalized. In this document, a model class is just a description for some ODESystem from ModelingToolkit.jl, which satisfies certain requirements. For example, any ODESystem is considered an \"Injector\" if it contains a connector Terminal() called :terminal.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"details: Code example: definition of PQ load as injector\nusing OpPoDyn, OpPoDyn.Library, ModelingToolkit\nusing ModelingToolkit: D_nounits as Dt, t_nounits as t\n@mtkmodel MyPQLoad begin\n    @components begin\n        terminal = Terminal()\n    end\n    @parameters begin\n        Pset, [description=\"Active Power demand\"]\n        Qset, [description=\"Reactive Power demand\"]\n    end\n    @variables begin\n        P(t), [description=\"Active Power\"]\n        Q(t), [description=\"Reactive Power\"]\n    end\n    @equations begin\n        P ~ terminal.u_r*terminal.i_r + terminal.u_i*terminal.i_i\n        Q ~ terminal.u_i*terminal.i_r - terminal.u_r*terminal.i_i\n        # if possible, its better for the solver to explicitly provide algebraic equations for the current\n        terminal.i_r ~ (Pset*terminal.u_r + Qset*terminal.u_i)/(terminal.u_r^2 + terminal.u_i^2)\n        terminal.i_i ~ (Pset*terminal.u_i - Qset*terminal.u_r)/(terminal.u_r^2 + terminal.u_i^2)\n    end\nend\nMyPQLoad(name=:pqload) #hide\nnothing #hide","category":"page"},{"location":"ModelingConcepts/#Model-class-MTKBus","page":"Modeling Concepts","title":"Model class MTKBus","text":"","category":"section"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"A MTKBus isa class of models, which are used to describe the dynamic behavior of a full bus in a power grid. Each MTKBus musst contain a predefined model of type BusBar() (named :busbar). This busbar represents the connection point to the grid. Optionally, it may contain various injectors.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":" ┌───────────────────────────────────┐\n │ MTKBus             ┌───────────┐  │\n │  ┌──────────┐   ┌──┤ Generator │  │\n │  │          │   │  └───────────┘  │\n │  │  BusBar  ├───o                 │\n │  │          │   │  ┌───────────┐  │\n │  └──────────┘   └──┤ Load      │  │\n │                    └───────────┘  │\n └───────────────────────────────────┘","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"Sometimes it is not possible to connect all injectors directly but instead one needs or wants Branches between the busbar and injector terminal. As long as the :busbar is present at the toplevel, there are few limitations on the overall model complexity.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"For simple models (direct connections of a few injectors) it is possible to use the convenience method MTKBus(injectors...) to create the composite model based on provide injector models.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"details: Code example: definition of a Bus containing a swing equation and a load\nusing OpPoDyn, OpPoDyn.Library, ModelingToolkit\n@mtkmodel MyMTKBus begin\n    @components begin\n        busbar = BusBar()\n        swing = Swing()\n        load = PQLoad()\n    end\n    @equations begin\n        connect(busbar.terminal, swing.terminal)\n        connect(busbar.terminal, load.terminal)\n    end\nend\nMyMTKBus(name=:bus) #hide\nnothing #hideAlternativly, for that system you could have just calledmybus = MTKBus(Swing(;name=:swing), PQLoad(;name=:load))\nnothing #hideto get an instance of a model which is structually aquivalent to MyMTKBus.","category":"page"},{"location":"ModelingConcepts/#Line-Modeling","page":"Modeling Concepts","title":"Line Modeling","text":"","category":"section"},{"location":"ModelingConcepts/#Model-class-Branch","page":"Modeling Concepts","title":"Model class Branch","text":"","category":"section"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"A branch is the two-port equivalent to an injector. I needs to have two Terminal()s, one is called :src, the other :dst.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"Examples for branches are: PI─Model branches, dynamic RL branches or transformers.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"      ┌───────────┐\n(src) │           │ (dst)\n  o←──┤  Branch   ├──→o\n      │           │\n      └───────────┘","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"Both ends follow the injector interface, i.e. current leaving the device towards the terminals is always positive.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"details: Code example: algebraic R-line\nusing OpPoDyn, OpPoDyn.Library, ModelingToolkit\n@mtkmodel MyRLine begin\n    @components begin\n        src = Terminal()\n        dst = Terminal()\n    end\n    @parameters begin\n        R=0, [description=\"Resistance\"]\n    end\n    @equations begin\n        dst.i_r ~ (dst.u_r - src.u_r)/R\n        dst.i_i ~ (dst.u_i - src.u_i)/R\n        src.i_r ~ -dst.i_r\n        src.i_i ~ -dst.i_i\n    end\nend\nMyRLine(name=:rline) #hide\nnothing #hide","category":"page"},{"location":"ModelingConcepts/#Model-class:-MTKLine","page":"Modeling Concepts","title":"Model class: MTKLine","text":"","category":"section"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"Similar to the MTKBus, a MTKLine is a model class which represents a transmission line in the network.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"It musst contain two LineEnd() instances, one called :src, one called :dst.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":" ┌────────────────────────────────────────────────┐\n │ MTKLine          ┌──────────┐                  │\n │  ┌─────────┐  ┌──┤ Branch A │──┐  ┌─────────┐  │\n │  │ LineEnd │  │  └──────────┘  │  │ LineEnd │  │\n │  │  :src   ├──o                o──┤  :dst   │  │\n │  │         │  │  ┌──────────┐  │  │         │  │\n │  └─────────┘  └──┤ Branch B │──┘  └─────────┘  │\n │                  └──────────┘                  │\n └────────────────────────────────────────────────┘","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"Simple line models, which consist only of valid Branch models can be instantiated using the MTKLine(branches...) constructor.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"More complex models can be created manually. For example if you want to chain multiple branches between the LineEnds, for example something like","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"LineEnd(:src) ──o── Transformer ──o── Pi─Line ──o── LineEnd(:dst)","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"details: Code example: Transmission line with two pi-branches\nusing OpPoDyn, OpPoDyn.Library, ModelingToolkit\n@mtkmodel MyMTKLine begin\n    @components begin\n        src = LineEnd()\n        dst = LineEnd()\n        branch1 = DynawoPiLine()\n        branch2 = DynawoPiLine()\n    end\n    @equations begin\n        connect(src.terminal, branch1.src)\n        connect(src.terminal, branch2.src)\n        connect(dst.terminal, branch1.dst)\n        connect(dst.terminal, branch2.dst)\n    end\nend\nMyMTKLine(name=:mtkline) #hide\nnothing #hideAlternatively, an equivalent model with multiple valid branch models in parallel could be created and instantiated with the convenience constructorline = MTKLine(DynawoPiLine(;name=:branch1), DynawoPiLine(;name=:branch2))\nnothing #hide","category":"page"},{"location":"ModelingConcepts/#From-MTK-Models-to-NetworkDynamics","page":"Modeling Concepts","title":"From MTK Models to NetworkDynamics","text":"","category":"section"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"Valid MTKLine and MTKBus can be transformed into so called Line and Bus objects.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"Line and Bus structs are no MTK models anymore, but rather containers. Currently, they mainly contain a NetworkDynamics component function (VertexModel, EdgeModel).","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"Eventually, those models will contain more metadata. For example","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"static representation for powerflow,\npossibly local information about PU system (for transforming parameters between SI/PU),\nmeta information for initialization, for example initialization model or the information which parameters are considered \"tunable\" in order to initialize the dynamical model","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"The exact structure here is not clear yet!","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"The result would look something like that:","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"using OpPoDyn, OpPoDyn.Library, ModelingToolkit\nusing Graphs, NetworkDynamics\nusing OrdinaryDiffEqRosenbrock, OrdinaryDiffEqNonlinearSolve\nusing CairoMakie\nnothing #hide","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"Define a swing bus with load","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"# define injectors\n@named swing = Swing(; Pm=1, V=1, D=0.1)\n@named load = PQLoad(; Pset=-.5, Qset=0)\nbus1mtk = MTKBus(swing, load; name=:swingbus)\nvertex1f = Bus(bus1mtk) # extract component function","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"Define a second bus as a slack","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"bus2mtk = SlackDifferential(; name=:slackbus)\nvertex2f = Bus(bus2mtk) # extract component function","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"Define the powerline connecting both nodes","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"@named branch1 = DynawoPiLine()\n@named branch2 = DynawoPiLine()\nlinemtk = MTKLine(branch1, branch2; name=:powerline)\nedgef = Line(linemtk) # extract component function","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"Define the graph, the network and extract initial conditions","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"g = complete_graph(2)\nnw = Network(g, [vertex1f, vertex2f], edgef)\nu0 = NWState(nw) # extract parameters and state from models\nu0.v[1, :swing₊θ] = 0 # set missing initial conditions\nu0.v[1, :swing₊ω] = 1","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"Then we can solve the problem","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"prob = ODEProblem(nw, uflat(u0), (0,1), pflat(u0))\nsol = solve(prob, Rodas5P())\n@assert OrdinaryDiffEqRosenbrock.SciMLBase.successful_retcode(sol) # hide\nnothing #hide","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"And finally we can plot the solution:","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"fig = Figure();\nax = Axis(fig[1,1])\nlines!(ax, sol; idxs=VIndex(1,:busbar₊P), label=\"Power injection Bus\", color=Cycled(1))\nlines!(ax, sol; idxs=VIndex(1,:swing₊Pel), label=\"Power injection Swing\", color=Cycled(2))\nlines!(ax, sol; idxs=VIndex(1,:load₊P), label=\"Power injection load\", color=Cycled(3))\naxislegend(ax)\n\nax = Axis(fig[2,1])\nlines!(ax, sol; idxs=VIndex(1,:busbar₊u_arg), label=\"swing bus voltage angle\", color=Cycled(1))\nlines!(ax, sol; idxs=VIndex(2,:busbar₊u_arg), label=\"slack bus voltage angle\", color=Cycled(2))\naxislegend(ax)\nfig #hide","category":"page"},{"location":"ModelingConcepts/#Internals","page":"Modeling Concepts","title":"Internals","text":"","category":"section"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"Internally, we use different input/output conventions for bus and line models. The predefined models BusBar() and LineEnd() are defined in the following way:","category":"page"},{"location":"ModelingConcepts/#Model:-BusBar()","page":"Modeling Concepts","title":"Model: BusBar()","text":"","category":"section"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"A busbar is a concrete model used in bus modeling. It represents the physical connection within a bus, the thing where all injectors and lines attach.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"           ┌──────────┐\ni_lines ──→│          │  (t)\n           │  Busbar  ├───o\n  u_bus ←──│          │\n           └──────────┘","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"It receives the sum of all line currents as an input and equals that to the currents flowing into the terminal. As an output, it gives forwards the terminal voltage to the backend.","category":"page"},{"location":"ModelingConcepts/#Model:-LineEnd()","page":"Modeling Concepts","title":"Model: LineEnd()","text":"","category":"section"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"A LineEnd model is very similar to the BusBar model. It represents one end of a transmission line.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"          ┌───────────┐\n u_bus ──→│           │  (t)\n          │  LineEnd  ├───o\ni_line ←──│           │\n          └───────────┘","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"It has special input/output connectors which handle the network interconnection. The main difference beeing the different input/output conventions for the network interface.","category":"page"},{"location":"#OpPoDyn","page":"Home","title":"OpPoDyn","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for OpPoDyn.","category":"page"},{"location":"#Project-Structure","page":"Home","title":"Project Structure","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The project is structured as follows","category":"page"},{"location":"","page":"Home","title":"Home","text":"OpPoDyn/\n├── assets: contains asses for reference tests\n├── docs: contains this documentation\n├── OpPoDynTesting: helper package for testing, defines test utilities like reference tests\n├── Project.toml\n├── src: source code\n│   ├── Library: submodule for library, all the models live here\n│   └── ...\n└── test: test code","category":"page"},{"location":"","page":"Home","title":"Home","text":"At this stage, this project is meant to be used with the main branch from NetworkDynamics. Unfortunately, it also depends on the unregistered subpackage OpPoDynTesting which makes instantiating the environment a bit tricky (because you can neither add NetworkDynamics#main nor OpPoDyntesting#../OpPoDynTesting without it complaining about the other dependency. Thanks to the [sources] block in Project.toml in Julia v1.11, this shouldn'te be a problem anymore.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you want to use the realse version of Julia v1.10 I suggest to create a new development environment:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> pwd() # make sure you're in the right folder\n\".../.julia/dev/OpPoDyn\"\n\n(v1.10) pkg> activate devenv\n\n(devenv) pkg> dev NetworkDynamics\n\n(devenv) pkg> dev ./OpPoDyntesting\n\n(devenv) pkg> dev .","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#OpPoDyn.ModelMetadataConstructor","page":"Home","title":"OpPoDyn.ModelMetadataConstructor","text":"This type wraps the default constructor of a ModelingToolkit.Model and allows to attach metadata to it. Two types of metadata is possible:\n\na \"name\" field which will become the \"name\" field of the system\na named tuple with aribrary fields which will become the \"metadata\" field of the system\n\n\n\n\n\n","category":"type"},{"location":"#OpPoDyn.separate_differential_constraint_eqs","page":"Home","title":"OpPoDyn.separate_differential_constraint_eqs","text":"separate_differential_constraint_eqs(M, p=nothing)\n\nReturns the constraint equations and differential equations indices from an ODEFunction h(x) used in DifferentialEquations.jl. The ODE h must be in Mass Matrix form meaning: M ẋ = h(x), with M diagonal. h should be inplace.\n\n\n\n\n\n","category":"function"},{"location":"#OpPoDyn.small_signal_stability_analysis","page":"Home","title":"OpPoDyn.small_signal_stability_analysis","text":"small_signal_stability_analysis(h::ODEFunction, eq_point, p = nothing)\n\nPerforms a small signal stability analysis according to: [1] \"Power System Modelling and Scripting\", F. Milano, Chapter 7.2. We find the reduced Jacobian (or State Matrix A_s) and calculate its eigenvalues. If the eigenvalues have positive real parts we classify the grid as unstable.\n\nh: Full DAE system\neq_point: Equilibrium point / fixed point of h. h(eq_point) = 0.0\n\n\n\n\n\n","category":"function"},{"location":"#OpPoDyn.@attach_metadata!-Tuple{Any, Any}","page":"Home","title":"OpPoDyn.@attach_metadata!","text":"@attach_metadata! Model metadata\n\nAllows you to attach additonal metadata to a Model which was previously defined using @mtkmodel. The metadata needs to be in the form of a named tuple (; name=..., field1=..., field2=...).\n\nIf name is present in the metadata, it will be used as the default name of the system and stripped from the metadata. The rest of the named tuple will be attachde to the ODESystems metadata.\n\n\n\n\n\n","category":"macro"},{"location":"#Funding","page":"Home","title":"Funding","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Development of this project was in part funded by the German Federal Ministry for Economic Affairs and Climate Action as part of the OpPoDyn-Project (Project ID 01258425/1, 2024-2027).","category":"page"},{"location":"","page":"Home","title":"Home","text":"<img src=\"assets/bmwk_logo_en.svg\" width=\"300\"/>","category":"page"},{"location":"generated/ieee9bus/#IEEE-9Bus-Example","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"","category":"section"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"In this example, we're going to model the IEEE 9 bus system.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"The parameters are mainly adopted from the RTDS data.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"using OpPoDyn\nusing OpPoDyn.Library\nusing ModelingToolkit\nusing NetworkDynamics\nusing Graphs\nusing OrdinaryDiffEqRosenbrock\nusing OrdinaryDiffEqNonlinearSolve\nusing CairoMakie","category":"page"},{"location":"generated/ieee9bus/#Generator-Busses","page":"IEEE 9Bus Example","title":"Generator Busses","text":"","category":"section"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"The 3 generator buses are modeld using a SauerPai 6th order machine model with variable field voltage and mechanical torque input. The field voltage is provided by an AVRTypeI, the torque is provide by a TGOV1 model.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"@mtkmodel GenBus begin\n    @components begin\n        machine = SauerPaiMachine(;\n            vf_input=true,\n            τ_m_input=true,\n            S_b=100,\n            V_b=1,\n            ω_b=2π*60,\n            R_s=0.000125,\n            T″_d0=0.01,\n            T″_q0=0.01,\n            X_d, X′_d, X″_d, X_q, X′_q, X″_q, X_ls, T′_d0, T′_q0, H # free per machine parameter\n        )\n        avr = AVRTypeI(vr_min=-5, vr_max=5,\n            Ka=20, Ta=0.2,\n            Kf=0.063, Tf=0.35,\n            Ke=1, Te=0.314,\n            E1=3.3, Se1=0.6602, E2=4.5, Se2=4.2662,\n            tmeas_lag=false)\n        gov = TGOV1(R=0.05, T1=0.05, T2=2.1, T3=7.0, DT=0, V_max=5, V_min=-5)\n        busbar = BusBar()\n    end\n    @equations begin\n        connect(machine.terminal, busbar.terminal)\n        connect(machine.v_mag_out, avr.v_mag)\n        connect(avr.vf, machine.vf_in)\n        connect(gov.τ_m, machine.τ_m_in)\n        connect(machine.ωout, gov.ω_meas)\n    end\nend\nnothing # hide","category":"page"},{"location":"generated/ieee9bus/#Load-Busses","page":"IEEE 9Bus Example","title":"Load Busses","text":"","category":"section"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"The dynamic loads are modeld as static Y-loads. Those have 3 parameters: Pset, Qset and Vset. The Vset parameter is left free for now. Later on it is automaticially determined to match the behavior of the static power flow load model.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"@mtkmodel LoadBus begin\n    @components begin\n        busbar = BusBar()\n        load = ConstantYLoad(Pset, Qset)\n    end\n    @equations begin\n        connect(load.terminal, busbar.terminal)\n    end\nend\nnothing #hide","category":"page"},{"location":"generated/ieee9bus/#Generate-Dynamical-models","page":"IEEE 9Bus Example","title":"Generate Dynamical models","text":"","category":"section"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"The parameters of the machines are obtaind from the data table from the RTDS datasheet.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"gen1p = (;machine__X_ls=0.01460, machine__X_d=0.1460, machine__X′_d=0.0608, machine__X″_d=0.06, machine__X_q=0.1000, machine__X′_q=0.0969, machine__X″_q=0.06, machine__T′_d0=8.96, machine__T′_q0=0.310, machine__H=23.64)\ngen2p = (;machine__X_ls=0.08958, machine__X_d=0.8958, machine__X′_d=0.1198, machine__X″_d=0.11, machine__X_q=0.8645, machine__X′_q=0.1969, machine__X″_q=0.11, machine__T′_d0=6.00, machine__T′_q0=0.535, machine__H= 6.40)\ngen3p = (;machine__X_ls=0.13125, machine__X_d=1.3125, machine__X′_d=0.1813, machine__X″_d=0.18, machine__X_q=1.2578, machine__X′_q=0.2500, machine__X″_q=0.18, machine__T′_d0=5.89, machine__T′_q0=0.600, machine__H= 3.01)\nnothing #hide","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"We instantiate all models as modeling toolkit models.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"@named mtkbus1 = GenBus(; gen1p...)\n@named mtkbus2 = GenBus(; gen2p...)\n@named mtkbus3 = GenBus(; gen3p...)\n@named mtkbus4 = MTKBus()\n@named mtkbus5 = LoadBus(;load__Pset=-1.25, load__Qset=-0.5)\n@named mtkbus6 = LoadBus(;load__Pset=-0.90, load__Qset=-0.3)\n@named mtkbus7 = MTKBus()\n@named mtkbus8 = LoadBus(;load__Pset=-1.0, load__Qset=-0.35)\n@named mtkbus9 = MTKBus()\nnothing #hide","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"After this, we can build the NetworkDynamics components using the Bus-constructor.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"The Bus constructor is essentially a thin wrapper around the VertexModel constructor which, per default, adds some metadata. For example the vidx property which later on allows for \"graph free\" network dynamics instantiation.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"We use the pf keyword to specify the models which should be used in the powerflow calculation. Here, generator 1 is modeld as a slack bus while the other two generators are modeled as a PV bus. The loads are modeled as PQ buses.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"@named bus1 = Bus(mtkbus1; vidx=1, pf=pfSlack(V=1.04))\n@named bus2 = Bus(mtkbus2; vidx=2, pf=pfPV(V=1.025, P=1.63))\n@named bus3 = Bus(mtkbus3; vidx=3, pf=pfPV(V=1.025, P=0.85))\n@named bus4 = Bus(mtkbus4; vidx=4)\n@named bus5 = Bus(mtkbus5; vidx=5, pf=pfPQ(P=-1.25, Q=-0.5))\n@named bus6 = Bus(mtkbus6; vidx=6, pf=pfPQ(P=-0.9, Q=-0.3))\n@named bus7 = Bus(mtkbus7; vidx=7)\n@named bus8 = Bus(mtkbus8; vidx=8, pf=pfPQ(P=-1.0, Q=-0.35))\n@named bus9 = Bus(mtkbus9; vidx=9)\nnothing #hide","category":"page"},{"location":"generated/ieee9bus/#Branches","page":"IEEE 9Bus Example","title":"Branches","text":"","category":"section"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"Branches and Transformers are build from the same PILine model with optional transformer on both ends. However, the data is provided in a way that the actual transformer values are 1.0. Apparently, the transforming action has been absorbed into the line parameters according to the base voltage on both ends.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"For the lines we again make use of the src and dst metadata of the EdgeModel objects for automatic graph construction.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"function piline(; R, X, B)\n    @named pibranch = PiLine(;R, X, B_src=B/2, B_dst=B/2, G_src=0, G_dst=0)\n    MTKLine(pibranch)\nend\nfunction transformer(; R, X)\n    @named transformer = PiLine(;R, X, B_src=0, B_dst=0, G_src=0, G_dst=0)\n    MTKLine(transformer)\nend\n\n@named l45 = Line(piline(; R=0.0100, X=0.0850, B=0.1760), src=4, dst=5)\n@named l46 = Line(piline(; R=0.0170, X=0.0920, B=0.1580), src=4, dst=6)\n@named l57 = Line(piline(; R=0.0320, X=0.1610, B=0.3060), src=5, dst=7)\n@named l69 = Line(piline(; R=0.0390, X=0.1700, B=0.3580), src=6, dst=9)\n@named l78 = Line(piline(; R=0.0085, X=0.0720, B=0.1490), src=7, dst=8)\n@named l89 = Line(piline(; R=0.0119, X=0.1008, B=0.2090), src=8, dst=9)\n@named t14 = Line(transformer(; R=0, X=0.0576), src=1, dst=4)\n@named t27 = Line(transformer(; R=0, X=0.0625), src=2, dst=7)\n@named t39 = Line(transformer(; R=0, X=0.0586), src=3, dst=9)\nnothing #hide","category":"page"},{"location":"generated/ieee9bus/#Build-Network","page":"IEEE 9Bus Example","title":"Build Network","text":"","category":"section"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"Finally, we can build the network by providing the vertices and edges.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"vertexfs = [bus1, bus2, bus3, bus4, bus5, bus6, bus7, bus8, bus9];\nedgefs = [l45, l46, l57, l69, l78, l89, t14, t27, t39];\nnw = Network(vertexfs, edgefs)","category":"page"},{"location":"generated/ieee9bus/#Powerflow","page":"IEEE 9Bus Example","title":"Powerflow","text":"","category":"section"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"To initialize the system, we first solve the static powerflow problem. Internally, OpPoDyn.jl builds an equivalent network but replaces each dynamic model with the given static power flow model. The static powerflow problem is solved, after which the power flow solution (bus voltages and currents) are stored as default values in the vertex models.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"solve_powerflow!(nw)\nnothing #hide","category":"page"},{"location":"generated/ieee9bus/#Component-initialization","page":"IEEE 9Bus Example","title":"Component initialization","text":"","category":"section"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"The power flow solution provided all the \"interface states\" (i.e. voltages and currents). With that information, we can initialize the free states and parameters of the dynamic models, such that the dynamic steady state matches the static power flow solution.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"When calling initialize!,  OpPoDyn.jl will loop through all the dynamic models in the system, automaticially creating and solving a nonlinear initialization problem for each of them.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"Concretly, here were solving for the following things:","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"unknown Vset for load busses,\nunknown internal machine and controller states as well as the free govenor and avr references (parameters) of the generator busses.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"OpPoDyn.initialize!(nw)\nnothing #hide","category":"page"},{"location":"generated/ieee9bus/#Disturbance","page":"IEEE 9Bus Example","title":"Disturbance","text":"","category":"section"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"To see some dynamics, we need to introduce some disturbance. For that we use a PresetTimeComponentCallback to deactivate a line at a certain time.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"deactivate_line = ComponentAffect([], [:pibranch₊active]) do u, p, ctx\n    @info \"Deactivate line $(ctx.src)=>$(ctx.dst) at t=$(ctx.t)\"\n    p[:pibranch₊active] = 0\nend\ncb = PresetTimeComponentCallback([1.0], deactivate_line)\nset_callback!(l46, cb)\nnothing # hide","category":"page"},{"location":"generated/ieee9bus/#Build-Network-2","page":"IEEE 9Bus Example","title":"Build Network","text":"","category":"section"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"Finally, we can build the network by providing the vertices and edges.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"u0 = NWState(nw)\nprob = ODEProblem(nw, uflat(u0), (0,15), pflat(u0); callback=get_callbacks(nw))\nsol = solve(prob, Rodas5P())\nnothing","category":"page"},{"location":"generated/ieee9bus/#Plotting-the-Solution","page":"IEEE 9Bus Example","title":"Plotting the Solution","text":"","category":"section"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"fig = Figure(size=(600,800));\nax = Axis(fig[1, 1]; title=\"Active power\")\nfor i in [1,2,3,5,6,8]\n    lines!(ax, sol; idxs=VIndex(i,:busbar₊P), label=\"Bus $i\", color=Cycled(i))\nend\naxislegend(ax)\nax = Axis(fig[2, 1]; title=\"Voltage magnitude\")\nfor i in 1:9\n    lines!(ax, sol; idxs=VIndex(i,:busbar₊u_mag), label=\"Bus $i\", color=Cycled(i))\nend\naxislegend(ax)\nax = Axis(fig[3, 1]; title=\"Frequency\")\nfor i in 1:3\n    lines!(ax, sol; idxs=VIndex(i,:machine₊ω), label=\"Bus $i\", color=Cycled(i))\nend\naxislegend(ax)\nfig #hide","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"This page was generated using Literate.jl.","category":"page"}]
}
