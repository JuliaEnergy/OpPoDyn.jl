var documenterSearchIndex = {"docs":
[{"location":"initialization/#Powergrid-Initialization","page":"Initialization","title":"Powergrid Initialization","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Initialization of power grid simulations requires a multi-step approach that combines steady-state power flow analysis with dynamic component initialization. OpPoDyn.jl provides a structured framework for this process, building on the initialization capabilities of NetworkDynamics.jl.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"For general background on NetworkDynamics initialization concepts, see the NetworkDynamics Initialization Guide.","category":"page"},{"location":"initialization/#Overview","page":"Initialization","title":"Overview","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Power grid initialization involves finding valid initial conditions that satisfy both:","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Power flow constraints: Electrical power balance equations (steady-state)\nDynamic constraints: Initial conditions for dynamic components (generators, controllers, etc.)","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"This is typically achieved through a two-step process:","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Solve the power flow problem to determine steady-state electrical conditions\nInitialize dynamic components using the power flow solution as boundary conditions","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"This follows the Two-Step Initialization Pattern described in NetworkDynamics.jl, specialized for power grid applications.","category":"page"},{"location":"initialization/#Multi-Step-Initialization-Process","page":"Initialization","title":"Multi-Step Initialization Process","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"nw = get_dynamic_network(...)\n\n# extract powerflow model       # ⎫                 ⎫\npfnw = powerflow_model(nw)      # │                 │\n# initial guess for powerflow   # ⎬ solve_powerflow │\npfs0 = NWState(pfnw)            # │                 │\n# find fixpoint for pf model    # │                 │\npfs = find_fixpoint(pfnw, pfs0) # ⎭                 ⎬ initialize_from_pf[!]\n# extract interface (u/i values)#                   │\ninterf = interface_values(pfs)  #                   │\n# initialize around powerflow   #                   │\ninitialize_componentwise[!](    #                   │\n    nw;                         #                   │\n    default_overrides = interf  #                   │\n)                               #                   ⎭","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"This low-level step-wise interface allows users full control and complete management of the initialization process. However, OpPoDyn.jl also provides higher-level wrapper functions solve_powerflow and initialize_from_pf that combine these steps for common use cases.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Note: This workflow above is slightly simplified, see Integration with Initialization Process below for the full set of commands.","category":"page"},{"location":"initialization/#Step-1:-Power-Flow-Model-Extraction","page":"Initialization","title":"Step 1: Power Flow Model Extraction","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"The first step creates a simplified, algebraic representation of the power grid that captures the essential power flow relationships:","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"pfnw = powerflow_model(nw)","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"This function extracts the power flow network from the full dynamic network model, creating a steady-state representation. The power flow network itself is also a Network in the NetworkDyanamics.jl sense.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"The powerflow_model function determines the appropriate power flow representation for each dynamic Node and LineModel by: checking if :pfmodel metadata is set, which points to a different component model specifically designed for power flow analysis","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"If the :pfmodel is not set, it assumes that the same model is used for both power flow and dynamic simulation. This is the case for purly static models such as PiLines or PQ-Loads.","category":"page"},{"location":"initialization/#Step-2:-Power-Flow-Solution","page":"Initialization","title":"Step 2: Power Flow Solution","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"The power flow problem is solved using NetworkDynamics.jl's find_fixpoint function, which internally uses NonlinearSolve.jl:","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"pfs0 = NWState(pfnw)            # Initial guess for power flow state\npfs = find_fixpoint(pfnw, pfs0) # Solve power flow equations","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"This step finds the steady-state solution where:","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Active and reactive power are balanced at each bus\nGeneration and load are in equilibrium","category":"page"},{"location":"initialization/#Step-3:-Interface-Value-Extraction","page":"Initialization","title":"Step 3: Interface Value Extraction","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"The power flow solution provides boundary conditions for dynamic component initialization:","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"interf = interface_values(pfs)","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"This extracts voltage magnitudes, voltage angles, and current flows at each network node, which serve as interface constraints for the dynamic components.","category":"page"},{"location":"initialization/#Step-4:-Component-wise-Dynamic-Initialization","page":"Initialization","title":"Step 4: Component-wise Dynamic Initialization","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Finally, each dynamic component is initialized individually using the power flow solution as boundary conditions:","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"initialize_componentwise!(nw; default_overrides = interf)","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"This step leverages NetworkDynamics.jl's component-wise initialization to determine free internal states and parameters (such as rotor angles or controller setpoints), such that the steady state of the overall network matches the flows from the power flow solution (i.e. all currents and voltages match).","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"For details on how component initialization works, see the Single Component Initialization section in NetworkDynamics.jl.","category":"page"},{"location":"initialization/#Advanced-Component-Initialization","page":"Initialization","title":"Advanced Component Initialization","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"In some cases, the standard initialization process may not be sufficient. For example, when component initialization constraints cannot be expressed solely in terms of interface variables (voltages and currents), but need access to other variables from the complete power flow solution.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"NetworkDynamics.jl provides general InitFormulas and InitConstraints for advanced component initialization. OpPoDyn.jl extends these concepts with power flow-aware variants that can access the complete power flow solution.","category":"page"},{"location":"initialization/#PFInitConstraints-vs-PFInitFormulas","page":"Initialization","title":"PFInitConstraints vs PFInitFormulas","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Method Purpose Usage\nPFInitConstraint Add constraint equations that must be satisfied When you need to enforce specific relationships between variables\nPFInitFormula Set default initial values directly When you need to initialize variables based on power flow results","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Both methods can access any variable from the solved power flow state, not just interface variables. You get access to states, parameters and observables from the power flow model of the same component.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Key difference: Constraints increase the number of equations that must be satisfied during initialization, while formulas reduce the number of free variables by setting additional default values.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"These are power flow-aware extensions of NetworkDynamics.jl's standard InitConstraint and InitFormula mechanisms.","category":"page"},{"location":"initialization/#Power-Flow-Dependent-Initialization-Constraints","page":"Initialization","title":"Power Flow Dependent Initialization Constraints","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"PFInitConstraint adds constraint equations to the initialization problem. Unlike regular InitConstraints from NetworkDynamics.jl, PFInitConstraints can access power flow variables.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"The @pfinitconstraint macro provides convenient syntax for defining these constraints:","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"# Single constraint accessing both component and power flow variables\nconstraint = @pfinitconstraint :dynamicload₊P - @pf(:PQ₊Pset)\n\n# Multiple constraints in a single block\nconstraints = @pfinitconstraint begin\n    :pibranch₊X - @pf(:pibranch₊X) # \"copy\" parameters from pf\n    :P_gen - @pf(:P_load)          # Power balance constraint\n    :AVR₊Vset - :busbar₊u_mag      # init controller setpoints\nend\n\n# Attach to a component\nset_pfinitconstraint!(my_generator, constraints)","category":"page"},{"location":"initialization/#Power-Flow-Dependent-Initialization-Formulas","page":"Initialization","title":"Power Flow Dependent Initialization Formulas","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"PFInitFormula sets default initial values for variables using both component and power flow variables. Unlike constraints, formulas directly assign values without adding equations to solve.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"The @pfinitformula macro provides convenient syntax:","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"# Single formula - set variable from component variables\n@pfinitformula :Vset = sqrt(:u_r^2 + :u_i^2)\n\n# Formula using power flow variables\n@pfinitformula :Pset = @pf(:generator_power)\n\n# Multiple formulas in a block\n@pfinitformula begin\n    :Vset = sqrt(:u_r^2 + :u_i^2)\n    :Pset = @pf(:generator_power)\nend\n\n# Attach to a component\nset_pfinitformula!(my_generator, formulas)","category":"page"},{"location":"initialization/#Integration-with-Initialization-Process","page":"Initialization","title":"Integration with Initialization Process","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Both PFInitConstraints and PFInitFormulas are automatically handled during initialize_from_pf[!]:","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Power flow solution: The power flow equations are solved first\nSpecialization: All PFInitConstraints and PFInitFormulas are converted to regular InitConstraints and InitFormulas by \"specializing\" them with the power flow solution (i.e. the @pf(:x) blocks are replaced by the actual values)\nComponent initialization: The specialized constraints and formulas are passed to NetworkDynamics.jl's component initialization","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"This process is transparent to the user - simply define your power flow dependent initialization methods and use initialize_from_pf[!] as usual.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"The underlying mechanism follows NetworkDynamics.jl's component initialization pipeline, with the power flow solution providing additional context for constraint and formula evaluation.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"The extended initializaion workflow (automaticially done in initialize_from_pf[!]) looks like this:","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"nw = get_dynamic_network(...)\npfnw = powerflow_model(nw)\npfs0 = NWState(pfnw)\npfs = find_fixpoint(pfnw, pfs0)\ninterf = interface_values(pfs)\n\n# specialize the constaints an formulas and pass then down\npfconstraints = specialize_pfinitconstraints(nw, pfs)\npfformulas    = specialize_pfinitformulas(nw, pfs)\ninitialize_componentwise[!](\n    nw;\n    default_overrides = interf,\n    additional_initconstraints = pfconstraints,\n    additional_initformulas = pfformulas,\n)","category":"page"},{"location":"ModelingConcepts/#Modeling-Concepts","page":"Modeling Concepts","title":"Modeling Concepts","text":"","category":"section"},{"location":"ModelingConcepts/#Terminal","page":"Modeling Concepts","title":"Terminal","text":"","category":"section"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"The Terminal─Connector is an important building block for every model. It represents a connection point with constant voltage in dq─cordinates u_r and u_i and enforces the kirchoff constraints sum(i_r)=0 and sum(i_i)=0.","category":"page"},{"location":"ModelingConcepts/#Modeling-of-Buses","page":"Modeling Concepts","title":"Modeling of Buses","text":"","category":"section"},{"location":"ModelingConcepts/#Model-class-Injector","page":"Modeling Concepts","title":"Model class Injector","text":"","category":"section"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"An injector is a class of components with a single Terminal() (called :terminal). Examples for injectors might be Generators, Shunts, Loads.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"      ┌───────────┐\n(t)   │           │\n o←───┤  Injector │\n      │           │\n      └───────────┘","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"The current for injectors is always in injector convention, i.e. positive currents flow out of the injector towards the terminal.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"note: Model classes\nModel \"classes\" are nothing formalized. In this document, a model class is just a description for some ODESystem from ModelingToolkit.jl, which satisfies certain requirements. For example, any ODESystem is considered an \"Injector\" if it contains a connector Terminal() called :terminal.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"details: Code example: definition of PQ load as injector\nusing OpPoDyn, OpPoDyn.Library, ModelingToolkit\nusing ModelingToolkit: D_nounits as Dt, t_nounits as t\n@mtkmodel MyPQLoad begin\n    @components begin\n        terminal = Terminal()\n    end\n    @parameters begin\n        Pset, [description=\"Active Power demand\"]\n        Qset, [description=\"Reactive Power demand\"]\n    end\n    @variables begin\n        P(t), [description=\"Active Power\"]\n        Q(t), [description=\"Reactive Power\"]\n    end\n    @equations begin\n        P ~ terminal.u_r*terminal.i_r + terminal.u_i*terminal.i_i\n        Q ~ terminal.u_i*terminal.i_r - terminal.u_r*terminal.i_i\n        # if possible, its better for the solver to explicitly provide algebraic equations for the current\n        terminal.i_r ~ (Pset*terminal.u_r + Qset*terminal.u_i)/(terminal.u_r^2 + terminal.u_i^2)\n        terminal.i_i ~ (Pset*terminal.u_i - Qset*terminal.u_r)/(terminal.u_r^2 + terminal.u_i^2)\n    end\nend\nMyPQLoad(name=:pqload) #hide\nnothing #hide","category":"page"},{"location":"ModelingConcepts/#Model-class-MTKBus","page":"Modeling Concepts","title":"Model class MTKBus","text":"","category":"section"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"A MTKBus isa class of models, which are used to describe the dynamic behavior of a full bus in a power grid. Each MTKBus musst contain a predefined model of type BusBar() (named :busbar). This busbar represents the connection point to the grid. Optionally, it may contain various injectors.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":" ┌───────────────────────────────────┐\n │ MTKBus             ┌───────────┐  │\n │  ┌──────────┐   ┌──┤ Generator │  │\n │  │          │   │  └───────────┘  │\n │  │  BusBar  ├───o                 │\n │  │          │   │  ┌───────────┐  │\n │  └──────────┘   └──┤ Load      │  │\n │                    └───────────┘  │\n └───────────────────────────────────┘","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"Sometimes it is not possible to connect all injectors directly but instead one needs or wants Branches between the busbar and injector terminal. As long as the :busbar is present at the toplevel, there are few limitations on the overall model complexity.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"For simple models (direct connections of a few injectors) it is possible to use the convenience method MTKBus(injectors...) to create the composite model based on provide injector models.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"details: Code example: definition of a Bus containing a swing equation and a load\nusing OpPoDyn, OpPoDyn.Library, ModelingToolkit\n@mtkmodel MyMTKBus begin\n    @components begin\n        busbar = BusBar()\n        swing = Swing()\n        load = PQLoad()\n    end\n    @equations begin\n        connect(busbar.terminal, swing.terminal)\n        connect(busbar.terminal, load.terminal)\n    end\nend\nMyMTKBus(name=:bus) #hide\nnothing #hideAlternativly, for that system you could have just calledmybus = MTKBus(Swing(;name=:swing), PQLoad(;name=:load))\nnothing #hideto get an instance of a model which is structually aquivalent to MyMTKBus.","category":"page"},{"location":"ModelingConcepts/#Line-Modeling","page":"Modeling Concepts","title":"Line Modeling","text":"","category":"section"},{"location":"ModelingConcepts/#Model-class-Branch","page":"Modeling Concepts","title":"Model class Branch","text":"","category":"section"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"A branch is the two-port equivalent to an injector. I needs to have two Terminal()s, one is called :src, the other :dst.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"Examples for branches are: PI─Model branches, dynamic RL branches or transformers.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"      ┌───────────┐\n(src) │           │ (dst)\n  o←──┤  Branch   ├──→o\n      │           │\n      └───────────┘","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"Both ends follow the injector interface, i.e. current leaving the device towards the terminals is always positive.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"details: Code example: algebraic R-line\nusing OpPoDyn, OpPoDyn.Library, ModelingToolkit\n@mtkmodel MyRLine begin\n    @components begin\n        src = Terminal()\n        dst = Terminal()\n    end\n    @parameters begin\n        R=0, [description=\"Resistance\"]\n    end\n    @equations begin\n        dst.i_r ~ (dst.u_r - src.u_r)/R\n        dst.i_i ~ (dst.u_i - src.u_i)/R\n        src.i_r ~ -dst.i_r\n        src.i_i ~ -dst.i_i\n    end\nend\nMyRLine(name=:rline) #hide\nnothing #hide","category":"page"},{"location":"ModelingConcepts/#Model-class:-MTKLine","page":"Modeling Concepts","title":"Model class: MTKLine","text":"","category":"section"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"Similar to the MTKBus, a MTKLine is a model class which represents a transmission line in the network.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"It musst contain two LineEnd() instances, one called :src, one called :dst.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":" ┌────────────────────────────────────────────────┐\n │ MTKLine          ┌──────────┐                  │\n │  ┌─────────┐  ┌──┤ Branch A │──┐  ┌─────────┐  │\n │  │ LineEnd │  │  └──────────┘  │  │ LineEnd │  │\n │  │  :src   ├──o                o──┤  :dst   │  │\n │  │         │  │  ┌──────────┐  │  │         │  │\n │  └─────────┘  └──┤ Branch B │──┘  └─────────┘  │\n │                  └──────────┘                  │\n └────────────────────────────────────────────────┘","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"Simple line models, which consist only of valid Branch models can be instantiated using the MTKLine(branches...) constructor.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"More complex models can be created manually. For example if you want to chain multiple branches between the LineEnds, for example something like","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"LineEnd(:src) ──o── Transformer ──o── Pi─Line ──o── LineEnd(:dst)","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"details: Code example: Transmission line with two pi-branches\nusing OpPoDyn, OpPoDyn.Library, ModelingToolkit\n@mtkmodel MyMTKLine begin\n    @components begin\n        src = LineEnd()\n        dst = LineEnd()\n        branch1 = DynawoPiLine()\n        branch2 = DynawoPiLine()\n    end\n    @equations begin\n        connect(src.terminal, branch1.src)\n        connect(src.terminal, branch2.src)\n        connect(dst.terminal, branch1.dst)\n        connect(dst.terminal, branch2.dst)\n    end\nend\nMyMTKLine(name=:mtkline) #hide\nnothing #hideAlternatively, an equivalent model with multiple valid branch models in parallel could be created and instantiated with the convenience constructorline = MTKLine(DynawoPiLine(;name=:branch1), DynawoPiLine(;name=:branch2))\nnothing #hide","category":"page"},{"location":"ModelingConcepts/#From-MTK-Models-to-NetworkDynamics","page":"Modeling Concepts","title":"From MTK Models to NetworkDynamics","text":"","category":"section"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"Valid MTKLine and MTKBus can be transformed into so called Line and Bus objects.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"Line and Bus structs are no MTK models anymore, but rather containers. Currently, they mainly contain a NetworkDynamics component function (VertexModel, EdgeModel).","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"Eventually, those models will contain more metadata. For example","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"static representation for powerflow,\npossibly local information about PU system (for transforming parameters between SI/PU),\nmeta information for initialization, for example initialization model or the information which parameters are considered \"tunable\" in order to initialize the dynamical model","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"The exact structure here is not clear yet!","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"The result would look something like that:","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"using OpPoDyn, OpPoDyn.Library, ModelingToolkit\nusing Graphs, NetworkDynamics\nusing OrdinaryDiffEqRosenbrock, OrdinaryDiffEqNonlinearSolve\nusing CairoMakie\nnothing #hide","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"Define a swing bus with load","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"# define injectors\n@named swing = Swing(; Pm=1, V=1, D=0.1)\n@named load = PQLoad(; Pset=-.5, Qset=0)\nbus1mtk = MTKBus(swing, load; name=:swingbus)\nvertex1f = Bus(bus1mtk) # extract component function","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"Define a second bus as a slack","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"bus2mtk = SlackDifferential(; name=:slackbus)\nvertex2f = Bus(bus2mtk) # extract component function","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"Define the powerline connecting both nodes","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"@named branch1 = DynawoPiLine()\n@named branch2 = DynawoPiLine()\nlinemtk = MTKLine(branch1, branch2; name=:powerline)\nedgef = Line(linemtk) # extract component function","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"Define the graph, the network and extract initial conditions","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"g = complete_graph(2)\nnw = Network(g, [vertex1f, vertex2f], edgef)\nu0 = NWState(nw) # extract parameters and state from models\nu0.v[1, :swing₊θ] = 0 # set missing initial conditions\nu0.v[1, :swing₊ω] = 1","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"Then we can solve the problem","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"prob = ODEProblem(nw, uflat(u0), (0,1), pflat(u0))\nsol = solve(prob, Rodas5P())\n@assert OrdinaryDiffEqRosenbrock.SciMLBase.successful_retcode(sol) # hide\nnothing #hide","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"And finally we can plot the solution:","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"fig = Figure();\nax = Axis(fig[1,1])\nlines!(ax, sol; idxs=VIndex(1,:busbar₊P), label=\"Power injection Bus\", color=Cycled(1))\nlines!(ax, sol; idxs=VIndex(1,:swing₊Pel), label=\"Power injection Swing\", color=Cycled(2))\nlines!(ax, sol; idxs=VIndex(1,:load₊P), label=\"Power injection load\", color=Cycled(3))\naxislegend(ax)\n\nax = Axis(fig[2,1])\nlines!(ax, sol; idxs=VIndex(1,:busbar₊u_arg), label=\"swing bus voltage angle\", color=Cycled(1))\nlines!(ax, sol; idxs=VIndex(2,:busbar₊u_arg), label=\"slack bus voltage angle\", color=Cycled(2))\naxislegend(ax)\nfig #hide","category":"page"},{"location":"ModelingConcepts/#Internals","page":"Modeling Concepts","title":"Internals","text":"","category":"section"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"Internally, we use different input/output conventions for bus and line models. The predefined models BusBar() and LineEnd() are defined in the following way:","category":"page"},{"location":"ModelingConcepts/#Model:-BusBar()","page":"Modeling Concepts","title":"Model: BusBar()","text":"","category":"section"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"A busbar is a concrete model used in bus modeling. It represents the physical connection within a bus, the thing where all injectors and lines attach.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"           ┌──────────┐\ni_lines ──→│          │  (t)\n           │  Busbar  ├───o\n  u_bus ←──│          │\n           └──────────┘","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"It receives the sum of all line currents as an input and equals that to the currents flowing into the terminal. As an output, it gives forwards the terminal voltage to the backend.","category":"page"},{"location":"ModelingConcepts/#Model:-LineEnd()","page":"Modeling Concepts","title":"Model: LineEnd()","text":"","category":"section"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"A LineEnd model is very similar to the BusBar model. It represents one end of a transmission line.","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"          ┌───────────┐\n u_bus ──→│           │  (t)\n          │  LineEnd  ├───o\ni_line ←──│           │\n          └───────────┘","category":"page"},{"location":"ModelingConcepts/","page":"Modeling Concepts","title":"Modeling Concepts","text":"It has special input/output connectors which handle the network interconnection. The main difference beeing the different input/output conventions for the network interface.","category":"page"},{"location":"#OpPoDyn","page":"Home","title":"OpPoDyn","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for OpPoDyn.","category":"page"},{"location":"#Project-Structure","page":"Home","title":"Project Structure","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The project is structured as follows","category":"page"},{"location":"","page":"Home","title":"Home","text":"OpPoDyn/\n├── assets: contains asses for reference tests\n├── docs: contains this documentation\n├── OpPoDynTesting: helper package for testing, defines test utilities like reference tests\n├── Project.toml\n├── src: source code\n│   ├── Library: submodule for library, all the models live here\n│   └── ...\n└── test: test code","category":"page"},{"location":"","page":"Home","title":"Home","text":"At this stage, this project is meant to be used with the main branch from NetworkDynamics. Unfortunately, it also depends on the unregistered subpackage OpPoDynTesting which makes instantiating the environment a bit tricky (because you can neither add NetworkDynamics#main nor OpPoDyntesting#../OpPoDynTesting without it complaining about the other dependency. Thanks to the [sources] block in Project.toml in Julia v1.11, this shouldn'te be a problem anymore.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you want to use the realse version of Julia v1.10 I suggest to create a new development environment:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> pwd() # make sure you're in the right folder\n\".../.julia/dev/OpPoDyn\"\n\n(v1.10) pkg> activate devenv\n\n(devenv) pkg> dev NetworkDynamics\n\n(devenv) pkg> dev ./OpPoDyntesting\n\n(devenv) pkg> dev .","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Funding","page":"Home","title":"Funding","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Development of this project was in part funded by the German Federal Ministry for Economic Affairs and Climate Action as part of the OpPoDyn-Project (Project ID 01258425/1, 2024-2027).","category":"page"},{"location":"","page":"Home","title":"Home","text":"<img src=\"assets/bmwk_logo_en.svg\" width=\"300\"/>","category":"page"},{"location":"generated/ieee9bus/#IEEE-9Bus-Example","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"","category":"section"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"In this example, we're going to model the IEEE 9 bus system.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"The parameters are mainly adopted from the RTDS data.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"using OpPoDyn\nusing OpPoDyn.Library\nusing ModelingToolkit\nusing NetworkDynamics\nusing Graphs\nusing OrdinaryDiffEqRosenbrock\nusing OrdinaryDiffEqNonlinearSolve\nusing CairoMakie","category":"page"},{"location":"generated/ieee9bus/#Generator-Busses","page":"IEEE 9Bus Example","title":"Generator Busses","text":"","category":"section"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"The 3 generator buses are modeld using a SauerPai 6th order machine model with variable field voltage and mechanical torque input. The field voltage is provided by an AVRTypeI, the torque is provide by a TGOV1 model.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"function GeneratorBus(; machine_p=(;), avr_p=(;), gov_p=(;))\n    @named machine = SauerPaiMachine(;\n        vf_input=true,\n        τ_m_input=true,\n        S_b=100,\n        V_b=1,\n        ω_b=2π*60,\n        R_s=0.000125,\n        T″_d0=0.01,\n        T″_q0=0.01,\n        machine_p... # unpack machine parameters\n    )\n    @named avr = AVRTypeI(; vr_min=-5, vr_max=5,\n        Ka=20, Ta=0.2,\n        Kf=0.063, Tf=0.35,\n        Ke=1, Te=0.314,\n        E1=3.3, Se1=0.6602, E2=4.5, Se2=4.2662,\n        tmeas_lag=false,\n        avr_p... # unpack AVR parameters\n    )\n    @named gov = TGOV1(; R=0.05, T1=0.05, T2=2.1, T3=7.0, DT=0, V_max=5, V_min=-5,\n        gov_p... # unpack governor parameters\n    )\n    # generate the \"injector\" as combination of multiple components\n    injector = CompositeInjector([machine, avr, gov]; name=:generator)\n\n    # generate the MTKBus (i.e. the MTK model containg the busbar and the injector)\n    mtkbus = MTKBus(injector)\nend\nnothing # hide","category":"page"},{"location":"generated/ieee9bus/#Load-Busses","page":"IEEE 9Bus Example","title":"Load Busses","text":"","category":"section"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"The dynamic loads are modeld as static Y-loads. Those have 3 parameters: Pset, Qset and Vset. For now, those parameters will be left free. We'll initialize them later on from the powerflow results.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"The Vset parameter is left free for now. Later on it is automaticially determined to match the behavior of the static power flow load model.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"function ConstantYLoadBus()\n    @named load = ConstantYLoad()\n    MTKBus(load; name=:loadbus)\nend\nnothing #hide","category":"page"},{"location":"generated/ieee9bus/#Generate-Dynamical-models","page":"IEEE 9Bus Example","title":"Generate Dynamical models","text":"","category":"section"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"The parameters of the machines are obtaind from the data table from the RTDS datasheet.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"gen1p = (;X_ls=0.01460, X_d=0.1460, X′_d=0.0608, X″_d=0.06, X_q=0.1000, X′_q=0.0969, X″_q=0.06, T′_d0=8.96, T′_q0=0.310, H=23.64)\ngen2p = (;X_ls=0.08958, X_d=0.8958, X′_d=0.1198, X″_d=0.11, X_q=0.8645, X′_q=0.1969, X″_q=0.11, T′_d0=6.00, T′_q0=0.535, H= 6.40)\ngen3p = (;X_ls=0.13125, X_d=1.3125, X′_d=0.1813, X″_d=0.18, X_q=1.2578, X′_q=0.2500, X″_q=0.18, T′_d0=5.89, T′_q0=0.600, H= 3.01)\nnothing #hide","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"We instantiate all models as modeling toolkit models.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"mtkbus1 = GeneratorBus(; machine_p=gen1p)\nmtkbus2 = GeneratorBus(; machine_p=gen2p)\nmtkbus3 = GeneratorBus(; machine_p=gen3p)\nmtkbus4 = MTKBus() # <- bus with no injectors, essentially\nmtkbus5 = ConstantYLoadBus()\nmtkbus6 = ConstantYLoadBus()\nmtkbus7 = MTKBus()\nmtkbus8 = ConstantYLoadBus()\nmtkbus9 = MTKBus()\nnothing #hide","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"After this, we can build the NetworkDynamics components using the Bus-constructor.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"The Bus constructor is essentially a thin wrapper around the VertexModel constructor which, per default, adds some metadata. For example the vidx property which later on allows for \"graph free\" network dynamics instantiation.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"We use the pf keyword to specify the models which should be used in the powerflow calculation. Here, generator 1 is modeld as a slack bus while the other two generators are modeled as a PV bus. The loads are modeled as PQ buses.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"@named bus1 = Bus(mtkbus1; vidx=1, pf=pfSlack(V=1.04))\n@named bus2 = Bus(mtkbus2; vidx=2, pf=pfPV(V=1.025, P=1.63))\n@named bus3 = Bus(mtkbus3; vidx=3, pf=pfPV(V=1.025, P=0.85))\n@named bus4 = Bus(mtkbus4; vidx=4)\n@named bus5 = Bus(mtkbus5; vidx=5, pf=pfPQ(P=-1.25, Q=-0.5))\n@named bus6 = Bus(mtkbus6; vidx=6, pf=pfPQ(P=-0.9, Q=-0.3))\n@named bus7 = Bus(mtkbus7; vidx=7)\n@named bus8 = Bus(mtkbus8; vidx=8, pf=pfPQ(P=-1.0, Q=-0.35))\n@named bus9 = Bus(mtkbus9; vidx=9)\nnothing #hide","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"Later on in initialization, we want to ensure that the internal parameters of the loads are initialized to match the powerflow results. We have 3 free parameters: Vset, Pset and Qset. To help the initialization, we can provide a InitFormula to set the Vset parameter to the voltage magnitude of the bus.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"vset_formula = @initformula :load₊Vset = sqrt(:busbar₊u_r^2 + :busbar₊u_i^2)\nadd_initformula!(bus5, vset_formula)\nadd_initformula!(bus6, vset_formula)\nadd_initformula!(bus8, vset_formula)","category":"page"},{"location":"generated/ieee9bus/#Branches","page":"IEEE 9Bus Example","title":"Branches","text":"","category":"section"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"Branches and Transformers are build from the same PILine model with optional transformer on both ends. However, the data is provided in a way that the actual transformer values are 1.0. Apparently, the transforming action has been absorbed into the line parameters according to the base voltage on both ends.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"For the lines we again make use of the src and dst metadata of the EdgeModel objects for automatic graph construction.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"function piline(; R, X, B)\n    @named pibranch = PiLine(;R, X, B_src=B/2, B_dst=B/2, G_src=0, G_dst=0)\n    MTKLine(pibranch)\nend\nfunction transformer(; R, X)\n    @named transformer = PiLine(;R, X, B_src=0, B_dst=0, G_src=0, G_dst=0)\n    MTKLine(transformer)\nend\n\n@named l45 = Line(piline(; R=0.0100, X=0.0850, B=0.1760), src=4, dst=5)\n@named l46 = Line(piline(; R=0.0170, X=0.0920, B=0.1580), src=4, dst=6)\n@named l57 = Line(piline(; R=0.0320, X=0.1610, B=0.3060), src=5, dst=7)\n@named l69 = Line(piline(; R=0.0390, X=0.1700, B=0.3580), src=6, dst=9)\n@named l78 = Line(piline(; R=0.0085, X=0.0720, B=0.1490), src=7, dst=8)\n@named l89 = Line(piline(; R=0.0119, X=0.1008, B=0.2090), src=8, dst=9)\n@named t14 = Line(transformer(; R=0, X=0.0576), src=1, dst=4)\n@named t27 = Line(transformer(; R=0, X=0.0625), src=2, dst=7)\n@named t39 = Line(transformer(; R=0, X=0.0586), src=3, dst=9)\nnothing #hide","category":"page"},{"location":"generated/ieee9bus/#Build-Network","page":"IEEE 9Bus Example","title":"Build Network","text":"","category":"section"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"Finally, we can build the network by providing the vertices and edges.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"vertexfs = [bus1, bus2, bus3, bus4, bus5, bus6, bus7, bus8, bus9];\nedgefs = [l45, l46, l57, l69, l78, l89, t14, t27, t39];\nnw = Network(vertexfs, edgefs; warn_order=false)","category":"page"},{"location":"generated/ieee9bus/#System-Initialization","page":"IEEE 9Bus Example","title":"System Initialization","text":"","category":"section"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"To initialize the system for dynamic simulation, we use initialize_from_pf! which performs a unified powerflow solving and component initialization process.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"Internally, this function:","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"Builds an equivalent static powerflow network from the dynamic models\nSolves the static powerflow equations using the specified powerflow models (pfSlack, pfPV, pfPQ)\nUses the powerflow solution to initialize all dynamic component states and parameters","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"This ensures that the dynamic model starts from a steady-state condition that matches the powerflow solution. Specifically, it determines:","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"Bus voltages and currents from the powerflow solution\nUnknown Vset parameters for load buses\nInternal machine states (flux linkages, rotor angles, etc.)\nController states and references for AVRs and governors","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"u0 = initialize_from_pf(nw);\nnothing #hide","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"We could check the initial state of some of the variables, we expect the model to be initialized in a way, that the setpoint of the constant Y-loads matches the powerfow constraints.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"u0[VIndex(5, :load₊Pset)] ≈ -1.25 && u0[VIndex(5, :load₊Qset)] ≈ -0.5","category":"page"},{"location":"generated/ieee9bus/#Disturbance","page":"IEEE 9Bus Example","title":"Disturbance","text":"","category":"section"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"To see some dynamics, we need to introduce some disturbance. For that we use a PresetTimeComponentCallback to deactivate a line at a certain time.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"deactivate_line = ComponentAffect([], [:pibranch₊active]) do u, p, ctx\n    @info \"Deactivate line $(ctx.src)=>$(ctx.dst) at t=$(ctx.t)\"\n    p[:pibranch₊active] = 0\nend\ncb = PresetTimeComponentCallback([1.0], deactivate_line)\nset_callback!(l46, cb)\nnothing # hide","category":"page"},{"location":"generated/ieee9bus/#Dynamic-Simulation","page":"IEEE 9Bus Example","title":"Dynamic Simulation","text":"","category":"section"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"With the system properly initialized, we can now set up and run the dynamic simulation. We create an ODE problem using the initialized state and simulate the system response to the line outage disturbance.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"prob = ODEProblem(nw, uflat(u0), (0,15), pflat(u0); callback=get_callbacks(nw))\nsol = solve(prob, Rodas5P())\nnothing","category":"page"},{"location":"generated/ieee9bus/#Plotting-the-Solution","page":"IEEE 9Bus Example","title":"Plotting the Solution","text":"","category":"section"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"Finally, we visualize the simulation results showing the system response to the line outage at t=1.0 seconds. The plots show active power, voltage magnitudes, and generator frequencies across the simulation time.","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"fig = Figure(size=(600,800));\n\n# Active power at selected buses\nax = Axis(fig[1, 1]; title=\"Active Power\", xlabel=\"Time [s]\", ylabel=\"Power [pu]\")\nfor i in [1,2,3,5,6,8]\n    lines!(ax, sol; idxs=VIndex(i,:busbar₊P), label=\"Bus $i\", color=Cycled(i))\nend\naxislegend(ax)\n\n# Voltage magnitude at all buses\nax = Axis(fig[2, 1]; title=\"Voltage Magnitude\", xlabel=\"Time [s]\", ylabel=\"Voltage [pu]\")\nfor i in 1:9\n    lines!(ax, sol; idxs=VIndex(i,:busbar₊u_mag), label=\"Bus $i\", color=Cycled(i))\nend\n\n# Generator frequencies\nax = Axis(fig[3, 1]; title=\"Generator Frequency\", xlabel=\"Time [s]\", ylabel=\"Frequency [pu]\")\nfor i in 1:3\n    lines!(ax, sol; idxs=VIndex(i,:generator₊machine₊ω), label=\"Gen $i\", color=Cycled(i))\nend\naxislegend(ax)\n\nfig #hide","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"","category":"page"},{"location":"generated/ieee9bus/","page":"IEEE 9Bus Example","title":"IEEE 9Bus Example","text":"This page was generated using Literate.jl.","category":"page"},{"location":"API/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"API/#Modeling-Tools","page":"API Reference","title":"Modeling Tools","text":"","category":"section"},{"location":"API/#Constructors-for-ND-Models","page":"API Reference","title":"Constructors for ND Models","text":"","category":"section"},{"location":"API/","page":"API Reference","title":"API Reference","text":"Those functions help you to bridge from MTK models to NetworkDynamics.jl Models:","category":"page"},{"location":"API/#OpPoDyn.Bus","page":"API Reference","title":"OpPoDyn.Bus","text":"Bus(sys::ODESystem; verbose=false, name=getname(sys), kwargs...)\n\nCreate a VertexModel from an ODESystem that satisfies the bus model interface.\n\nArguments\n\nsys::ODESystem: The system must satisfy the bus model interface (see isbusmodel)\nverbose::Bool=false: Enable verbose output during creation\nname: Name for the bus (defaults to system name)\nkwargs...: Additional keyword arguments passed to the Bus constructor\n\nReturns\n\nA VertexModel representing the bus\n\n\n                                          ╔═════════════════════════╗\n                                          ║ VertexModel (compiled)  ║\n    ┌────────────────────┐      Network   ║  ┌────────────────────┐ ║\n    │MTKBus   ┌─────────┐│     interface  ║  │MTKBus   ┌─────────┐│ ║\n    │        ┌┤Generator││                ║  │        ┌┤Generator││ ║\n    │┌──────┐│└─────────┘│      current ────→│┌──────┐│└─────────┘│ ║\nBus(││BusBar├o           │) =>            ║  ││BusBar├o           │ ║\n    │└──────┘│┌────┐     │      voltage ←────│└──────┘│┌────┐     │ ║\n    │        └┤Load│     │                ║  │        └┤Load│     │ ║\n    │         └────┘     │                ║  │         └────┘     │ ║\n    └────────────────────┘                ║  └────────────────────┘ ║\n                                          ╚═════════════════════════╝\n\nSee also: MTKBus\n\n\n\n\n\n","category":"function"},{"location":"API/#OpPoDyn.Line","page":"API Reference","title":"OpPoDyn.Line","text":"Line(sys::ODESystem; verbose=false, name=getname(sys), kwargs...)\n\nCreate an EdgeModel from an ODESystem that satisfies the line model interface.\n\nArguments\n\nsys::ODESystem: The system must satisfy the line model interface (see islinemodel)\nverbose::Bool=false: Enable verbose output during creation\nname: Name for the line (defaults to system name)\nkwargs...: Additional keyword arguments passed to the Line constructor\n\nReturns\n\nAn EdgeModel representing the line\n\n\n                                             ╔══════════════════════════════╗\n                                             ║ EdgeModel (compiled)         ║\n     ┌─────────────────────────────┐     src ║ ┌──────────────────────────┐ ║ dst\n     │MTKLine   ┌───────┐          │  vertex ║ │MTKLine   ┌────┐          │ ║ vertex\n     │         ┌┤BranchA├┐         │         ║ │         ┌┤    ├┐         │ ║\n     │┌───────┐│└───────┘│┌───────┐│     u ───→│┌───────┐│└────┘│┌───────┐│←─── u\nLine(││LineEnd├o         o┤LineEnd││) =>     ║ ││LineEnd├o      o┤LineEnd││ ║\n     │└───────┘│┌───────┐│└───────┘│     i ←───│└───────┘│┌────┐│└───────┘│───→ i\n     │  :src   └┤BranchB├┘  :dst   │         ║ │         └┤    ├┘         │ ║\n     │          └───────┘          │         ║ │          └────┘          │ ║\n     └─────────────────────────────┘         ║ └──────────────────────────┘ ║\n                                             ╚══════════════════════════════╝\n\nSee also: MTKLine\n\n\n\n\n\n","category":"function"},{"location":"API/#Basic-Component-Modeling","page":"API Reference","title":"Basic Component Modeling","text":"","category":"section"},{"location":"API/#OpPoDyn.Terminal","page":"API Reference","title":"OpPoDyn.Terminal","text":"Terminal\n\nA ModelingToolkit connector for electrical terminals in power system components.\n\nRepresents an electrical connection point with complex voltage and current in dq coordinates. The terminal defines the interface between power system components like buses, lines, and machines.\n\nVariables\n\nu_r(t): d-axis voltage component\nu_i(t): q-axis voltage component\ni_r(t): d-axis current component (flow variable)\ni_i(t): q-axis current component (flow variable)\n\nNotes\n\nCurrent variables are defined as flow variables, meaning they sum to zero at connection points according to Kirchhoff's current law.\n\nSee also: BusBar, LineEnd\n\n\n\n\n\n","category":"constant"},{"location":"API/#OpPoDyn.BusBar","page":"API Reference","title":"OpPoDyn.BusBar","text":"@named busbar = BusBar()\n\nA ModelingToolkit model representing the physical connection point within a bus in power systems. It represents the physical busbar where all injectors and lines attach.\n\nWithin OpPoDyn.jl, it serves as an interface between the MTK world and the NetworkDynamics world: A MTK model containing a BusBar the highest level is consdered a busmodel (see isbusmodel) and describes the dynamics of an entire bus. It can be transformed in a VertexModel by calling Bus.\n\nSee also: Terminal, MTKBus, Bus\n\n\n\n\n\n","category":"constant"},{"location":"API/#OpPoDyn.LineEnd","page":"API Reference","title":"OpPoDyn.LineEnd","text":"LineEnd\n\nA ModelingToolkit model representing one end of a transmission line in power systems. It represents the physical connection point at the end of a transmission line.\n\nWithin OpPoDyn.jl, it serves as an interface between the MTK world and the NetworkDynamics world: A MTK model containing two LineEnds (named :src and :dst) at the highest level is considered a linemodel (see islinemodel) and describes the dynamics of an entire line. It can be transformed in an EdgeModel by calling Line.\n\nSee also: Terminal, MTKLine, Line\n\n\n\n\n\n","category":"constant"},{"location":"API/#OpPoDyn.MTKBus","page":"API Reference","title":"OpPoDyn.MTKBus","text":"MTKBus(injectors...; name=:bus)\n\nCreate a ModelingToolkit bus system by connecting multiple injector components.\n\nConstructs a bus ODESystem by connecting all provided injector components to a central BusBar. Each injector component must satisfy the injector model interface (see isinjectormodel).\n\nArguments\n\ninjectors...: Variable number of injector components (generators, loads, etc.)\nname=:bus: Name for the resulting bus system\n\nReturns\n\nAn ODESystem representing the complete bus with all connected injectors\n\n                                 ┌────────────────────┐\n                                 │MTKBus   ┌─────────┐│\n                                 │        ┌┤Generator││\n        ┌─────────┐   ┌────┐     │┌──────┐│└─────────┘│\nMTKBus(o┤Generator│, o┤Load│) => ││BusBar├o           │\n        └─────────┘   └────┘     │└──────┘│┌────┐     │\n                                 │        └┤Load│     │\n                                 │         └────┘     │\n                                 └────────────────────┘\n\nSee also: Bus, BusBar, isinjectormodel\n\n\n\n\n\n","category":"function"},{"location":"API/#OpPoDyn.MTKLine","page":"API Reference","title":"OpPoDyn.MTKLine","text":"MTKLine(branches...; name=:line)\n\nCreate a ModelingToolkit line system by connecting multiple branch components.\n\nConstructs a line ODESystem by connecting all provided branch components between source and destination line ends in parallel. Each branch component must satisfy the branch model interface.\n\nArguments\n\nbranches...: Variable number of branch components (transmission lines, transformers, etc.)\nname=:line: Name for the resulting line system\n\nReturns\n\nAn ODESystem representing the complete line with all connected branches\n\n                                     ┌─────────────────────────────┐\n                                     │MTKLine   ┌───────┐          │\n                                     │         ┌┤BranchA├┐         │\n         ┌───────┐    ┌───────┐      │┌───────┐│└───────┘│┌───────┐│\nMTKLine(o┤BranchA├o, o┤BranchB├o) => ││LineEnd├o         o┤LineEnd││\n         └───────┘    └───────┘      │└───────┘│┌───────┐│└───────┘│\n                                     │  :src   └┤BranchB├┘  :dst   │\n                                     │          └───────┘          │\n                                     └─────────────────────────────┘\n\nSee also: Line, LineEnd, isbranchmodel\n\n\n\n\n\n","category":"function"},{"location":"API/#OpPoDyn.CompositeInjector","page":"API Reference","title":"OpPoDyn.CompositeInjector","text":"CompositeInjector(systems, eqs=autoconnections(systems); name=Symbol(join(getname.(systems), \"_\")))\n\nCreate an injector object which contains several subsystems. Every subsystem which has a terminal will be connected to a newly created terminal of the composite injector. The subsystems are namespaced within the composite injector.\n\nThere are two options for additional connections between the subsystems:\n\ninterconnections will be created automatically using some name-matching heuristics using autoconnections(systems): It searches all Blocks.RealOutput and Blocks.RealInput, and tries to find a single matching output for each input.\nalternatively pass connecting equations of the form [connect(sys1.output, sys2.input)] explicitly\n\nFor example, one could create a composite injector with three subsystems:\n\na generator,\na controller, and\na load;\n\nwhich is augmented with 2 connection equations\n\none for the measurements (generator -> controller), and\none for the actuation (controller -> generator).\n\nThe returned model contains a new terminal :terminal at the toplevel, thus satisfying the injector interface, see isinjectormodel). It can be used as such in the MTKBus constructor.\n\n    ┌────────────────────────────────────┐\n    │ CompositeInjector                  │\n    │              ╭───→───╮ measurements│\n    │    ┌─────────┴─┐   ┌─┴──────────┐  │\n(t) │  o─┤ Generator │   │ Controller │  │\n o──┼──┤ └─────────┬─┘   └─┬──────────┘  │\n    │  │           ╰───←───╯ actuation   │\n    │  │ ┌──────┐                        │\n    │  o─┤ Load │                        │\n    │    └──────┘                        │\n    └────────────────────────────────────┘\n\n\n\n\n\n","category":"function"},{"location":"API/#Helpers","page":"API Reference","title":"Helpers","text":"","category":"section"},{"location":"API/#OpPoDyn.isbusmodel","page":"API Reference","title":"OpPoDyn.isbusmodel","text":"isbusmodel(sys::ODESystem)\n\nCheck if an ODESystem satisfies the bus model interface.\n\nA bus model must contain a component named :busbar that satisfies the busbar interface. Bus models represent the complete dynamics of a power system bus and can be transformed into a VertexModel using Bus.\n\n┌───────────────────────────┐\n│BusModel     ┌────────────┐│\n│           ┌─┤ Injector 1 ││\n│┌────────┐ │ └────────────┘│\n││ BusBar ├─o               │\n│└────────┘ │               │\n│ :busbar   └ ...           │\n│                           │\n└───────────────────────────┘\n\nNote: The BusModel musst contain exaclty one BusBar, the rest of the structure is free. For example, you could also put a Brach between an injector and a Busbar or have multiple injectors and controllers connected.\n\nSee also: Bus, BusBar, MTKBus\n\n\n\n\n\n","category":"function"},{"location":"API/#OpPoDyn.isinjectormodel","page":"API Reference","title":"OpPoDyn.isinjectormodel","text":"isinjectormodel(sys::ODESystem)\n\nCheck if an ODESystem satisfies the injector model interface.\n\nAn injector model must contain a Terminal named :terminal. Injector models represent components like generators, loads, and other devices that connect to a single bus. They can have arbitrary internal complexity as long as they have exactly one terminal.\n\n   (t)    ┌──────────┐\n    o─────┤ Injector │\n:terminal └──────────┘\n\nSee also: Terminal\n\n\n\n\n\n","category":"function"},{"location":"API/#OpPoDyn.islinemodel","page":"API Reference","title":"OpPoDyn.islinemodel","text":"islinemodel(sys::ODESystem)\n\nCheck if an ODESystem satisfies the line model interface.\n\nA line model must contain two components named :src and :dst that both satisfy the line end interface. Line models represent transmission lines and can be transformed into an EdgeModel using Line.\n\n┌──────────────────────────────────────┐\n│LineModel     ┌────────┐              │\n│            ┌─┤ Branch ├─┐            │\n│┌─────────┐ │ └────────┘ │ ┌─────────┐│\n││ LineEnd ├─o            o─┤ LineEnd ││\n│└─────────┘ │            │ └─────────┘│\n│   :src     └    ....    ┘    :dst    │\n│                                      │\n└──────────────────────────────────────┘\n\nNote: Between the LineEnds there can be arbeitrary structures, for example branches in series or parallel.\n\nSee also: Line, LineEnd, MTKBus\n\n\n\n\n\n","category":"function"},{"location":"API/#OpPoDyn.isbranchmodel","page":"API Reference","title":"OpPoDyn.isbranchmodel","text":"isbranchmodel(sys::ODESystem)\n\nCheck if an ODESystem satisfies the branch model interface.\n\nA branch model must contain two Terminal components named :src and :dst. Branch models represent two-port network elements like transmission lines, transformers, and other connecting devices.\n\n (t) ┌────────┐ (t)\n  o──┤ Branch ├──o\n:src └────────┘ :dst\n\nSee also: Terminal\n\n\n\n\n\n","category":"function"},{"location":"API/#Powerflow-Tools","page":"API Reference","title":"Powerflow Tools","text":"","category":"section"},{"location":"API/#Powerflow-Components","page":"API Reference","title":"Powerflow Components","text":"","category":"section"},{"location":"API/#OpPoDyn.pfSlack","page":"API Reference","title":"OpPoDyn.pfSlack","text":"pfSlack(; V=missing, δ=missing, u_r=missing, u_i=missing)\n\nCreate a slack bus for power flow analysis.\n\nA slack bus maintains constant voltage magnitude and phase angle (or real and imaginary voltage components). Either provide voltage magnitude V and phase angle δ, or provide real and imaginary voltage components u_r and u_i.\n\n\n\n\n\n","category":"function"},{"location":"API/#OpPoDyn.pfPV","page":"API Reference","title":"OpPoDyn.pfPV","text":"pfPV(; P, V)\n\nCreate a PV bus for power flow analysis.\n\nA PV bus maintains constant active power injection and voltage magnitude. The reactive power and voltage phase angle are determined by the power flow solution.\n\n\n\n\n\n","category":"function"},{"location":"API/#OpPoDyn.pfPQ","page":"API Reference","title":"OpPoDyn.pfPQ","text":"pfPQ(; P=0, Q=0)\n\nCreate a PQ bus for power flow analysis.\n\nA PQ bus has specified active and reactive power injections. The voltage magnitude and phase angle are determined by the power flow solution.\n\n\n\n\n\n","category":"function"},{"location":"API/#Powerflow-Helpers","page":"API Reference","title":"Powerflow Helpers","text":"","category":"section"},{"location":"API/#OpPoDyn.solve_powerflow","page":"API Reference","title":"OpPoDyn.solve_powerflow","text":"solve_powerflow(nw::Network;\n                pfnw = powerflow_model(nw),\n                pfs0 = NWState(nw),\n                verbose=true)\n\nSolve the power flow equations for a given network.\n\nUses find_fixpoint from NetworkDynamics to solve the algebraic power flow equations.\n\nParameters\n\nnw: The dynamic network model\npfnw: The power flow network model (default: created from nw)\npfs0: Initial state for the power flow calculation\nverbose: Whether to print the power flow solution\n\nReturns\n\nA NWState containing the solved power flow solution\n\nSee also initialize_from_pf.\n\n\n\n\n\n","category":"function"},{"location":"API/#OpPoDyn.initialize_from_pf","page":"API Reference","title":"OpPoDyn.initialize_from_pf","text":"initialize_from_pf[!](\n    nw::Network;\n    verbose = true,\n    subverbose = false,\n    pfnw = powerflow_model(nw),\n    pfs0 = NWState(pfnw),\n    pfs = solve_powerflow(pfnw; pfs0, verbose),\n    kwargs...\n)\n\nInitialize a dynamic network model from a power flow solution.\n\nThis function performs a two-step initialization process:\n\nSolve the power flow equations for the network\nUse the power flow solution to initialize the dynamic model\n\nThere are two versions of this function: a mutating one (!-at the end of name) and a non-mutating version. The mutating version uses initialize_componentwise! internally, the non-mutating one initialize_componentwise. When the mutating version is used, NWState(nw) after initialization will return the same initialized state again, as it is stored in the metadata.\n\nParameters\n\nnw: The dynamic network model to initialize\nverbose: Whether to print information about the power flow solution (default: true)\nsubverbose: Whether to print detailed information during component initialization (default: false). Can be Vector [VIndex(1), EIndex(3), ...] for selective output\npfnw: Power flow network model (default: created from nw using powerflow_model)\npfs0: Initial state for power flow calculation (default: created from pfnw)\npfs: Power flow solution (default: calculated using solve_powerflow)\nAdditional keyword arguments are passed to initialize_componentwise[!]\n\nReturns\n\nA fully initialized network state\n\nSee also: solve_powerflow, initialize_componentwise, interface_values\n\n\n\n\n\n","category":"function"},{"location":"API/#OpPoDyn.show_powerflow","page":"API Reference","title":"OpPoDyn.show_powerflow","text":"show_powerflow(s::NWState/Network)\n\nDisplay power flow results in a tabular format.\n\nExtract and format power flow solution data from a network state, showing bus-level information including voltage magnitudes, phase angles, active power, and reactive power.\n\n\n\n\n\n","category":"function"},{"location":"API/#OpPoDyn.powerflow_model","page":"API Reference","title":"OpPoDyn.powerflow_model","text":"powerflow_model(cf::NetworkDynamics.ComponentModel)\n\nExtract or create a power flow component model from a dynamic component model.\n\nIf the component has :pfmodel metadata, use that model (after validation)\nIf the component is already a valid power flow model (i.e. no ODE, just constraints), return it as-is\n\nReturns\n\nA component model suitable for power flow analysis (no dynamics)\n\nValidation\n\nThe returned model must satisfy ispfmodel criteria:\n\nEither no states or zero mass matrix (no dynamics)\n\nSee also: ispfmodel, pfSlack, pfPV, pfPQ\n\n\n\n\n\npowerflow_model(nw::Network)\n\nCreate a power flow network model from a dynamic network model.\n\nThis method applies powerflow_model to all vertex and edge components in the network, creating a new network suitable for steady-state power flow analysis.\n\nReturns a new Network with the same graph structure but power flow component models\n\nSee also: solve_powerflow\n\n\n\n\n\n","category":"function"},{"location":"API/#OpPoDyn.ispfmodel","page":"API Reference","title":"OpPoDyn.ispfmodel","text":"ispfmodel(cf::NetworkDynamics.ComponentModel)\n\nCheck if a component model is suitable for power flow analysis.\n\nA component model is considered a valid power flow model if it has no dynamics, i.e., either no states or a zero mass matrix.\n\nReturns\n\ntrue if the component is suitable for power flow analysis\nfalse otherwise\n\n\n\n\n\n","category":"function"},{"location":"API/#Initialization","page":"API Reference","title":"Initialization","text":"","category":"section"},{"location":"API/#Powerflow-dependent-constraints-and-formulas","page":"API Reference","title":"Powerflow dependent constraints and formulas","text":"","category":"section"},{"location":"API/#OpPoDyn.PFInitConstraint","page":"API Reference","title":"OpPoDyn.PFInitConstraint","text":"struct PFInitConstraint{F}\nPFInitConstraint(f, sym, pfsym, dim)\n\nA representation of an additional constraint that is applied during the initialization phase of a component. In contrast to a InitConstraint, this constraint may access additional variables which are available in the full NWState of the solved power flow!\n\nCrucially, this is only necessary for constraints, which cannot be expressed in terms of the interface variables (voltages and currents).\n\nSee also: @pfinitconstraint for a macro to create such constraints, PFInitConstraint, set_pfinitconstraint!, add_pfinitconstraint!\n\n\n\n\n\n","category":"type"},{"location":"API/#OpPoDyn.@pfinitconstraint","page":"API Reference","title":"OpPoDyn.@pfinitconstraint","text":"@pfinitconstraint expr\n@pfinitconstraint begin\n    constraint1\n    constraint2\nend\n\nCreate a PFInitConstraint using macro syntax. Component variables are accessed with :symbol and power flow state variables with @pf :symbol. Multiple constraints can be defined in a begin...end block.\n\nSee also: PFInitConstraint, set_pfinitconstraint!, add_pfinitconstraint!\n\n\n\n\n\n","category":"macro"},{"location":"API/#OpPoDyn.PFInitFormula","page":"API Reference","title":"OpPoDyn.PFInitFormula","text":"struct PFInitFormula{F}\nPFInitFormula(f, outsym, sym, pfsym)\n\nA representation of an initialization formula that is applied during the initialization phase of a component. In contrast to a InitFormula, this formula may access additional variables which are available in the full NWState of the solved power flow!\n\nCrucially, this is only necessary for formulas, which cannot be expressed in terms of the interface variables (voltages and currents).\n\nSimilar to InitFormula, this sets defaults rather than adding constraint equations. The formula is applied early in the initialization pipeline before constraints are solved.\n\nSee also: @pfinitformula for a macro to create such formulas, PFInitFormula, set_pfinitformula!, add_pfinitformula!\n\n\n\n\n\n","category":"type"},{"location":"API/#OpPoDyn.@pfinitformula","page":"API Reference","title":"OpPoDyn.@pfinitformula","text":"@pfinitformula expr\n@pfinitformula begin\n    :var1 = expr1\n    :var2 = expr2\nend\n\nCreate a PFInitFormula using macro syntax. Component variables are accessed with :symbol and power flow state variables with @pf :symbol. Multiple formulas can be defined in a begin...end block.\n\nUnlike constraints, formulas use assignment syntax (:var = expression) to set variable values during initialization. The left-hand side specifies output variables, and the right-hand side can access both component variables and power flow state variables.\n\nSee also: PFInitFormula, set_pfinitformula!, add_pfinitformula!\n\n\n\n\n\n","category":"macro"},{"location":"API/#OpPoDyn.copy_pf_parameters","page":"API Reference","title":"OpPoDyn.copy_pf_parameters","text":"copy_pf_parameters(cm::ComponentModel) -> PFInitFormula\n\nCreates a PFInitFormula that copies all parameters from the powerflow model to the component model. This formula can then be added to the component using add_pfinitformula!.\n\nThis is useful for components where the powerflow and dynamic models should have identical parameter values, ensuring consistency between the two models.\n\nSee also: PFInitFormula, add_pfinitformula!\n\n\n\n\n\n","category":"function"},{"location":"API/#Metadata-Accesors","page":"API Reference","title":"Metadata Accesors","text":"","category":"section"},{"location":"API/#OpPoDyn.add_pfinitformula!","page":"API Reference","title":"OpPoDyn.add_pfinitformula!","text":"add_pfinitformula!(c::NetworkDynamics.ComponentModel, formula::PFInitFormula) -> Bool\nadd_pfinitformula!(nw::Network, idx::Union{VIndex,EIndex}, formula) -> Bool\n\nAdds a new initialization formula which depends on the powerflow solution to the component. If formulas already exist, the new formula is added to the existing ones. If no formulas exist, this is equivalent to set_pfinitformula!.\n\nReturns true if the formula was successfully added, false if it already exists.\n\nSee also set_pfinitformula!, delete_pfinitformulas!.\n\n\n\n\n\n","category":"function"},{"location":"API/#OpPoDyn.set_pfinitformula!","page":"API Reference","title":"OpPoDyn.set_pfinitformula!","text":"set_pfinitformula!(c::NetworkDynamics.ComponentModel, formula; check=true)\nset_pfinitformula!(nw::Network, idx::Union{VIndex,EIndex}, formula; check=true)\n\nSets initialization formulas which depend on the powerflow solution to the component. Accepts either a single PFInitFormula or a tuple of PFInitFormula objects. Overwrites any existing pf formulas. See also delete_pfinitformulas!, add_pfinitformula!.\n\n\n\n\n\n","category":"function"},{"location":"API/#OpPoDyn.has_pfinitformula","page":"API Reference","title":"OpPoDyn.has_pfinitformula","text":"has_pfinitformula(c::ComponentModel)\nhas_pfinitformula(nw::Network, idx::Union{VIndex,EIndex})\n\nChecks if the component has an initialization formula which depends on the pf state in metadata.\n\nSee also: get_pfinitformulas, set_pfinitformula!.\n\n\n\n\n\n","category":"function"},{"location":"API/#OpPoDyn.get_pfinitformulas","page":"API Reference","title":"OpPoDyn.get_pfinitformulas","text":"get_pfinitformulas(c::NetworkDynamics.ComponentModel)\nget_pfinitformulas(nw::Network, idx::Union{VIndex,EIndex})\n\nRetrieves the initialization formulas which depend on pf state for the component model. Returns a tuple of formulas, even if only one formula is present. May error if no formulas are present. Use has_pfinitformula to check first.\n\nSee also: has_pfinitformula, set_pfinitformula!.\n\n\n\n\n\n","category":"function"},{"location":"API/#OpPoDyn.delete_pfinitformulas!","page":"API Reference","title":"OpPoDyn.delete_pfinitformulas!","text":"delete_pfinitformulas!(c::NetworkDynamics.ComponentModel)\ndelete_pfinitformulas!(nw::Network, idx::Union{VIndex,EIndex})\n\nRemoves the powerflow dependent initialization formula from the component model, or from a component referenced by idx in a network. Returns true if the formula existed and was removed, false otherwise.\n\nSee also: set_pfinitformula!.\n\n\n\n\n\n","category":"function"},{"location":"API/#OpPoDyn.add_pfinitconstraint!","page":"API Reference","title":"OpPoDyn.add_pfinitconstraint!","text":"add_pfinitconstraint!(c::NetworkDynamics.ComponentModel, constraint::PFInitConstraint) -> Bool\nadd_pfinitconstraint!(nw::Network, idx::Union{VIndex,EIndex}, constraint) -> Bool\n\nAdds a new initialization constraint which depends on the powerflow solution to the component. If constraints already exist, the new constraint is added to the existing ones. If no constraints exist, this is equivalent to set_pfinitconstraint!.\n\nReturns true if the constraint was successfully added, false if it already exists.\n\nSee also set_pfinitconstraint!, delete_pfinitconstraints!.\n\n\n\n\n\n","category":"function"},{"location":"API/#OpPoDyn.set_pfinitconstraint!","page":"API Reference","title":"OpPoDyn.set_pfinitconstraint!","text":"set_pfinitconstraint!(c::NetworkDynamics.ComponentModel, constraint; check=true)\nset_pfinitconstraint!(nw::Network, idx::Union{VIndex,EIndex}, constraint; check=true)\n\nSets initialization constraints which depend on the powerflow solution to the component. Accepts either a single PFInitConstraint or a tuple of PFInitConstraint objects. Overwrites any existing pf constraints. See also delete_pfinitconstraints!, add_pfinitconstraint!.\n\n\n\n\n\n","category":"function"},{"location":"API/#OpPoDyn.has_pfinitconstraint","page":"API Reference","title":"OpPoDyn.has_pfinitconstraint","text":"has_pfinitconstraint(c::ComponentModel)\nhas_pfinitconstraint(nw::Network, idx::Union{VIndex,EIndex})\n\nChecks if the component has an initialization constraint which depends on the pf state in metadata.\n\nSee also: get_pfinitconstraints, set_pfinitconstraint!.\n\n\n\n\n\n","category":"function"},{"location":"API/#OpPoDyn.get_pfinitconstraints","page":"API Reference","title":"OpPoDyn.get_pfinitconstraints","text":"get_pfinitconstraints(c::NetworkDynamics.ComponentModel)\nget_pfinitconstraints(nw::Network, idx::Union{VIndex,EIndex})\n\nRetrieves the initialization constraints which depend on pf state for the component model. Returns a tuple of constraints, even if only one constraint is present. May error if no constraints are present. Use has_pfinitconstraint to check first.\n\nSee also: has_pfinitconstraint, set_pfinitconstraint!.\n\n\n\n\n\n","category":"function"},{"location":"API/#OpPoDyn.delete_pfinitconstraints!","page":"API Reference","title":"OpPoDyn.delete_pfinitconstraints!","text":"delete_pfinitconstraints!(c::NetworkDynamics.ComponentModel)\ndelete_pfinitconstraints!(nw::Network, idx::Union{VIndex,EIndex})\n\nRemoves the powerflow dependent initialization constraint from the component model, or from a component referenced by idx in a network. Returns true if the constraint existed and was removed, false otherwise.\n\nSee also: set_pfinitconstraint!.\n\n\n\n\n\n","category":"function"}]
}
